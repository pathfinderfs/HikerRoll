<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hike Tracker</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        h1,
        h2,
        h3 {
            color: #333;
        }

        button {
            background-color: #007AFF;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            margin: 10px 0;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            width: 100%;
            text-align: center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        button:active {
            transform: scale(0.98);
        }

        input[type="text"],
        input[type="tel"],
        input[type="datetime-local"] {
            width: 100%;
            padding: 12px 20px;
            margin: 8px 0;
            display: inline-block;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-sizing: border-box;
            font-size: 16px;
        }

        .hike-list {
            list-style-type: none;
            padding: 0;
        }

        .hike-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            padding-top: 0;
            margin-bottom: 10px;
        }

        .participant-list {
            list-style-type: none;
            padding: 0;
        }

        .participant-item {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #4CD964;
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .toggle-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-label {
            margin-left: 10px;
            margin-right: 10px;
        }

        .button-secondary {
            background-color: #FF3B30;
        }

        .button-refresh {
            background-color: #4CD964;
        }

        @media (hover: hover) {
            button:hover {
                background-color: #0056b3;
            }

            .button-secondary:hover {
                background-color: #d63a2f;
            }

            .button-refresh:hover {
                border: 3px solid #3cb371;
                /* solves sticky problem */
            }

            .autocomplete-items div:hover {
                background-color: #e9e9e9;
            }

            .flatpickr-input:hover {
                background-color: #f0f0f0;
            }

            .participant-table tr:hover {
                background-color: #f5f5f5;
            }

        }

        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
        }

        .autocomplete-items div {
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border-bottom: 1px solid #d4d4d4;
        }

        .autocomplete-active {
            background-color: DodgerBlue !important;
            color: #ffffff;
        }

        .autocomplete {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .flatpickr-input {
            background-color: #fff;
            cursor: pointer;
        }

        .date-time-picker-container {
            position: relative;
            margin-bottom: 15px;
        }

        .date-time-picker-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .date-time-picker-container::after {
            content: "\1F4C5";
            /* Calendar emoji */
            position: absolute;
            top: 35px;
            right: 10px;
            font-size: 20px;
            pointer-events: none;
        }

        .participant-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .participant-table th,
        .participant-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .participant-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        .participant-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* Default: Hide wide-only columns for narrow screens */
        .participant-table .col-wide-only {
            display: none;
        }

        /* Styling for paired buttons to sit side-by-side */
        .button-pair {
            display: flex;
            gap: 10px; /* Space between buttons */
            margin-top: 10px; /* Add some space above the button pair */
        }

        .button-pair button {
            flex-grow: 1; /* Allow buttons to share space equally */
            flex-basis: 0; /* Ensures equal distribution of space, ignoring content width */
            width: auto; /* Override default 100% width if necessary */
            margin: 0; /* Remove individual button margins if they interfere */
        }
        /* End of button-pair styling */

        /* Compact hike info display adjustments */
        .hike-item h3,
        #hike-leader-page h1,
        #hiking-page h1 {
            margin-bottom: 5px; /* Reduce space after the main title line */
            font-size: 1.2em; /* Slightly adjust H3/H1 if needed, can be page-specific */
        }

        .hike-item p,
        #hike-leader-page #leader-org-display,
        #hike-leader-page p[id^="hike-start-time"], /* Catches hike-start-time-leader-display */
        #hiking-page #hiking-leader-org,
        #hiking-page p[id^="hike-start-time"] /* Catches hike-start-time-display */
         {
            margin-top: 3px;
            margin-bottom: 3px;
            font-size: 0.9em; /* Ensure info lines are slightly smaller */
        }

        /* Specific adjustment for H1 on leader/hiking pages if 1.2em is too small */
        #hike-leader-page h1,
        #hiking-page h1 {
            font-size: 1.5em; /* Restore or set appropriate H1 size */
             margin-bottom: 8px;
        }
        /* End of Compact hike info display adjustments */

        /* Styling for button groups within the hike leader page */
        #hike-leader-page .button-group {
            display: flex;
            justify-content: space-between; /* Or space-around, or use 'flex-start' to pack left */
            gap: 10px; /* Adds space between buttons in the group */
            margin-bottom: 10px; /* Space below the button group */
        }

        #hike-leader-page .button-group button {
            flex-grow: 1; /* Allows buttons to grow and share space */
            flex-basis: 0; /* Ensures equal distribution of space, ignoring content width */
            width: auto; /* Override any specific width to allow flex sizing */
            /* Consider if full-width default button style needs override here for non-mobile */
            /* For example, if buttons are 100% width by default: */
            /* width: auto; might not be enough, could need max-width or flex-basis */
        }
        /* End of button group styling for hike leader page */

        @media screen and (max-width: 600px) {
            .participant-table {
                font-size: 14px;
            }

            .participant-table th,
            .participant-table td {
                padding: 6px;
            }
        }

        /* Coordinator Console Mobile Optimizations */
        @media screen and (max-width: 600px) {
            #hike-leader-page h1 {
                font-size: 1.5em; /* Slightly reduce title size */
                margin-bottom: 10px;
            }

            #hike-leader-page p {
                font-size: 0.9em; /* Reduce font size for info text */
                margin: 5px 0; /* Reduce vertical margins */
            }

            #hike-leader-page .button-refresh,
            #hike-leader-page .button-secondary,
            #hike-leader-page button,
            #download-participants-button { /* Ensure download button is included */
                padding: 10px 15px;
                font-size: 0.95em;
                /* width: auto; remove fixed width if any button has it by default */
            }

            /* Participant List Controls Compact Layout */

            /* Ensure table cells on mobile are not too padded */
            #hike-leader-page .participant-table th,
            #hike-leader-page .participant-table td {
                padding: 5px; /* Reduced padding for mobile table view */
            }

            #hike-leader-page .toggle-container {
                display: flex;
                align-items: center;
                justify-content: space-between; /* This will help space out toggle and count */
                margin-bottom: 10px; /* Give some space below this line */
            }

            /* Styling for the toggle part if needed, e.g., to prevent it from stretching too much */
            #hike-leader-page .toggle-container > .switch {
                margin-right: 5px; /* Space between "All" and the count if not using margin-left: auto on count */
            }
             #hike-leader-page .toggle-container > .toggle-label {
                white-space: nowrap; /* Prevent labels from wrapping */
            }


            #hike-leader-page #participant-count {
                /* margin-left: auto; is now inline, can be controlled here too if preferred */
                font-size: 0.85em;
                margin-top: 0; /* Reset top margin */
                margin-bottom: 0; /* Reset bottom margin */
                /* margin-left: 15px; Remove this if using margin-left: auto */
                text-align: right; /* Ensure text aligns to right if container is wider */
            }
        }

        /* Wider screens: Show wide-only columns */
        @media screen and (min-width: 768px) { /* Breakpoint for landscape phones / tablets */
            .participant-table .col-wide-only {
                display: table-cell; /* Or revert to default display for th/td */
            }
        }
    </style>
</head>

<body>
    <div id="status-indicators" style="position: fixed; top: 10px; right: 10px; z-index: 1000; display: flex; flex-direction: column; gap: 5px;">
      <div id="online-status-indicator" style="padding: 5px 10px; background-color: lightgray; border-radius: 5px; display: none;">Offline</div>
      <div id="sync-status-indicator" style="padding: 5px 10px; background-color: lightblue; border-radius: 5px; display: none;">Syncing... (0)</div>
    </div>
    <div class="container">
        <div id="welcome-page" style="display:none;">
            <h1>Hiker Roll Call</h1>
            <button onclick="showCreateHikePage()">Create New Hike</button>

            <h2>Upcoming</h2>
            <ul id="rsvped-hikes-list" class="hike-list"></ul>

            <h2>Leading</h2>
            <ul id="leading-hikes-list" class="hike-list"></ul>

            <h2>Nearby</h2>
            <button class="button-refresh" onclick="fetchAllWelcomePageHikes()">ðŸ”„ Refresh All</button>
            <ul id="nearby-hikes" class="hike-list"></ul>
        </div>

        <div id="create-hike-page" style="display:none;">
            <h1>Create Hike</h1>
            <form id="create-hike-form">
                <input type="text" id="hike-name" placeholder="Hike Name (e.g., Sunset Hike)" required>
                <input type="text" id="hike-organization" placeholder="Organization">
                <div class="autocomplete">
                    <input type="text" id="hike-trailheadName" placeholder="Trailhead Name (Type to search)" required>
                </div>
                <input type="text" id="leader-name" placeholder="Your Name" required>
                <input type="tel" id="leader-phone" placeholder="Your Phone (10 digits)" required maxlength="10"
                    pattern="\d{3}-\d{3}-\d{4}">
                <div class="date-time-picker-container">
                    <label for="hike-startTime">Hike Start Date and Time:</label>
                    <input type="text" id="hike-startTime" placeholder="Click to select date and time" required>
                </div>
                <div class="toggle-container">
                    <label for="hike-photo-release" class="toggle-label">Include Photo Release in Waiver?</label>
                    <label class="switch">
                        <input type="checkbox" id="hike-photo-release">
                        <span class="slider"></span>
                    </label>
                </div>
                <textarea id="hike-description" placeholder="Hike Description (optional, will auto-populate from your last hike of the same name if left blank)" style="width: 100%; min-height: 80px; margin-top: 8px; padding: 10px; border: 1px solid #ccc; border-radius: 10px; box-sizing: border-box; font-size: 16px;"></textarea>
                <button type="button" onclick="createHike()">Create Hike</button>
                <button type="button" class="button-secondary" onclick="cancelCreateHike()">Cancel</button>
            </form>
        </div>

        <div id="join-hike-page" style="display:none;">
            <h1>RSVP to Hike: <span id="join-hike-name"></span></h1>
            <p>Organization: <span id="join-hike-organization"></span></p>
            <p>Trailhead: <span id="join-trailhead-name"></span></p>
            <p>Start Time: <span id="join-hike-start-time"></span></p>
            <p>Description: <span id="join-hike-description" style="white-space: pre-wrap;"></span></p>
            <p>Please fill out the following to RSVP for this hike.</p>
            <form id="join-hike-form">
                <input type="text" id="participant-name" placeholder="Your Name" required>
                <input type="tel" id="participant-phone" placeholder="Your Phone (10 digits)" required maxlength="10"
                    pattern="\d{3}-\d{3}-\d{4}">
                <input type="text" id="participant-licensePlate" placeholder="License Plate (Optional)">
                <input type="tel" id="participant-emergencyContact" placeholder="Emergency Contact (10 digits)"
                    maxlength="10" pattern="\d{3}-\d{3}-\d{4}">
                <button type="button" onclick="showWaiverPage()">Review Waiver & Continue RSVP</button>
                <button type="button" class="button-secondary" onclick="cancelJoinHike()">Cancel</button>
            </form>
        </div>

        <div id="waiver-page" style="display:none;">
            <h1>Hike Waiver & RSVP Confirmation</h1>
            <div id="waiver-content"></div>
            <button onclick="joinHike()">Accept Waiver & Submit RSVP</button>
            <button class="button-secondary" onclick="cancelWaiver()">Cancel</button>
        </div>

        <div id="hike-leader-page" style="display:none;">
            <h1><a href="#" id="leader-hike-name-link" onclick="showDescriptionPopup(event)"><span id="hike-name-title-display"></span></a> (TH: <a id="trailhead-link-leader" href="#" target="_blank"><span id="trailhead-name-display"></span></a>)</h1>
            <p><span id="hike-start-time-leader-display"></span></p>
            <p id="leader-org-display"></p>
            <p style="display:none;">Organization: <span id="hike-organization-display"></span></p> <!-- Kept for JS to hide, or remove if JS adapted -->
            <p>Join Hike Link: <a id="join-url" onclick="copyToClipboard(event)">Press to copy</a></p>
            <p>Hike Coordinator Link: <a id="hike-leader-link" onclick="copyToClipboard(event)">Press to copy</a></span>
            </p>
            <h3>Participant List</h3>
            <p id="last-refresh"></p>
            <div class="button-group">
                <button class="button-refresh" onclick="refreshParticipants()">ðŸ”„ Refresh</button>
                <button id="download-participants-button" onclick="downloadParticipantList()">Download List</button>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Active</span>
                <label class="switch">
                    <input type="checkbox" id="participant-toggle" onchange="toggleParticipants()">
                    <span class="slider"></span>
                </label>
                <span class="toggle-label">All</span>
                <p id="participant-count" style="margin-left: auto;"></p> <!-- Moved and added inline style for alignment -->
            </div>
            <table id="participant-table" class="participant-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Phone</th>
                        <th class="col-wide-only">License Plate</th>
                        <th class="col-wide-only">Emergency Contact</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="participant-list">
                    <!-- Participants will be dynamically added here -->
                </tbody>
            </table>
            <div class="button-pair">
                <button class="button-secondary" onclick="endHike()">End Hike</button>
                <button type="button" style="background-color: #555;" onclick="goHomeFromLeaderConsole()">Home / Welcome Page</button>
            </div>
        </div>

        <div id="hiking-page" style="display:none;">
            <h1><span id="current-hike-name"></span> (TH: <a id="current-trailhead-name" href="" target="_blank"></a>)</h1>
            <p><span id="hike-start-time-display"></span></p>
            <p id="hiking-leader-org"></p>
            <p id="hiking-page-description" style="white-space: pre-wrap; font-size: 0.9em; color: #333; background-color: #f9f9f9; padding: 10px; border-radius: 5px; margin-top: 5px;"></p>
            <button class="button-secondary" onclick="leaveHike()">Leave Hike</button>
        </div>
    </div>

    <script>
        // Initialize app state
        let allParticipants = []; // used in hike-leader-page
        let showAllParticipants = false; // used in hike-leader-page
        let startTimeFlatpikr; // used in create-hike-page

        let currentUser = JSON.parse(localStorage.getItem('currentUser')) || {
            uuid: '',
            name: '',
            phone: '',
            licensePlate: '',
            emergencyContact: ''
        };
        if (!currentUser.uuid) {
            currentUser.uuid = crypto.randomUUID()
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
        }

        let currentHike = JSON.parse(localStorage.getItem('currentHike')) || emptyHike();

        function emptyHike() {
            return {
                name: '',
                organization: '',
                trailheadName: '',
                joinCode: '',
                leader: currentUser,
                startTime: new Date().toISOString(),
                latitude: 0,
                longitude: 0,
                photoRelease: false,
                description: '',
            };
        }

        function clearCurrentHike() {
            currentHike = emptyHike();
            localStorage.setItem('currentHike', JSON.stringify(currentHike));
        }

        function formatHikeStartTime(isoString) {
            const date = new Date(isoString);
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const dayName = days[date.getDay()];
            const monthName = months[date.getMonth()];
            const dayOfMonth = date.getDate();
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // the hour '0' should be '12'
            const hoursStr = hours.toString(); // No padStart needed for 12hr format typically

            return `${dayName}, ${monthName} ${dayOfMonth}, ${hoursStr}:${minutes} ${ampm}`;
        }

        // Initialize autocomplete and flatpickr on page load
        document.addEventListener("DOMContentLoaded", () => {
            autocomplete(document.getElementById("hike-trailheadName")); // Use the new ID for trailhead autocomplete
            startTimeFlatpikr = flatpickr("#hike-startTime", {
                enableTime: true,
                altInput: true,
                altFormat: "F j, Y at h:i K",
                minDate: "today",
                time_24hr: false
            });
            // Initialize the app
            checkUserStatus();
        });

        function checkUserStatus() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinCode = urlParams.get('code');
            const leaderCode = urlParams.get('leaderCode') || currentHike.leaderCode;

            if (leaderCode) {
                // Verify the hike is open and exists
                // TODO: should we allow updating of leader info?
                fetch(`/api/hike/${joinCode}?leaderCode=${leaderCode}`)
                    .then(response => response.json())
                    .then(hike => {
                        currentHike = hike;
                        currentHike.leaderCode = leaderCode;
                        hike.leader = currentUser;
                        localStorage.setItem('currentHike', JSON.stringify(currentHike));
                        showHikeLeaderPage();
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('The hike may not exist or has already ended.');
                        clearCurrentHike();
                        showWelcomePage();
                    });
            } else if (currentHike.joinCode) {
                // If currentHike already has a jointcode then the user is already in a hike so show the hiking page
                // TODO: Do we want to verify the hike is still open and they are still a participant?
                showHikingPage();
            } else if (joinCode) {
                showJoinHikePage(joinCode);
            } else {
                // User is not leading or participating in a hike so show the welcome page
                showWelcomePage();
            }
        }

        function showPage(pageId) {
            document.querySelectorAll('.container > div').forEach(div => div.style.display = 'none');
            document.getElementById(pageId).style.display = 'block';
        }

        function showWelcomePage() {
            showPage('welcome-page');
            // All data fetching for welcome page is now consolidated
            fetchAllWelcomePageHikes();
        }

        function fetchAllWelcomePageHikes() {
            const nearbyList = document.getElementById('nearby-hikes');
            const rsvpList = document.getElementById('rsvped-hikes-list');
            const leadingList = document.getElementById('leading-hikes-list');

            // Clear previous content and set loading messages
            nearbyList.innerHTML = '<li>Loading nearby hikes...</li>';
            rsvpList.innerHTML = '<li>Loading RSVPed hikes...</li>';
            leadingList.innerHTML = '<li>Loading hikes you are leading...</li>';

            let apiUrl = `/api/hike?userUUID=${currentUser.uuid}`;

            if ("geolocations" in navigator) {
                navigator.geolocation.getCurrentPosition(position => {
                    apiUrl += `&latitude=${position.coords.latitude}&longitude=${position.coords.longitude}`;
                    fetchHikes(apiUrl);
                }, error => {
                    console.error("Error getting location for welcome page:", error);
                    // Proceed without location data if geolocation fails
                    fetchHikes(apiUrl);
                });
            } else {
                console.log("Geolocation is not supported by this browser. Cannot fetch nearby hikes.");
                // Proceed without location data
                fetchHikes(apiUrl);
            }
        }

        function fetchHikes(url) {
            const nearbyList = document.getElementById('nearby-hikes');
            const rsvpList = document.getElementById('rsvped-hikes-list');
            const leadingList = document.getElementById('leading-hikes-list');

            // Ensure lists are cleared before processing new data or error messages
            nearbyList.innerHTML = '';
            rsvpList.innerHTML = '';
            leadingList.innerHTML = '';

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    return response.json();
                })
                .then(hikes => {
                    let foundNearby = false;
                    let foundRsvp = false;
                    let foundLeading = false;

                    if (!hikes || hikes.length === 0) {
                        // Handled by individual list checks below
                    } else {
                        hikes.forEach(hike => {
                            const li = document.createElement('li');
                            li.className = 'hike-item';
                            let buttonHtml = '';

                            if (hike.sourceType === 'location') {
                                buttonHtml = `<button onclick="showJoinHikePage('${hike.joinCode}')">RSVP to Hike</button>`;
                                li.innerHTML = `
                                    <h3>${hike.name} (TH: <a href="${makeTrailheadURL(hike)}" target="_blank">${hike.trailheadName}</a>)</h3>
                                    <p>${formatHikeStartTime(hike.startTime)}</p>
                                    <p>${hike.leader.name} ${hike.organization ? '(' + hike.organization + ')' : ''}</p>
                                    <p class="hike-description-display" style="white-space: pre-wrap; font-size: 0.85em; color: #555;">${hike.description || 'No description available.'}</p>
                                    ${buttonHtml}
                                `;
                                nearbyList.appendChild(li);
                                foundNearby = true;
                            } else if (hike.sourceType === 'rsvp') {
                                const participantId = hike.participantId || 0;
                                buttonHtml = `
                                <div class="button-pair">
                                    <button onclick="startHiking('${hike.joinCode}', ${participantId})">Start Hiking</button>
                                    <button class="button-secondary" onclick="unRSVP('${hike.joinCode}', ${participantId})">UnRSVP</button>
                                </div>
                                `;
                                let leaderLineRsvp = '';
                                if (hike.leader && hike.leader.name) { // Check if leader info is present
                                    leaderLineRsvp = `<p>${hike.leader.name} ${hike.organization ? '(' + hike.organization + ')' : ''}</p>`;
                                } else if (hike.organization) { // Fallback if only organization is known for the hike
                                    leaderLineRsvp = `<p>Organization: ${hike.organization}</p>`;
                                }

                                li.innerHTML = `
                                    <h3><a href="#" class="hike-name-link" data-description="${hike.description || ''}" onclick="showDescriptionPopup(event)">${hike.name}</a> (TH: <a href="${makeTrailheadURL(hike)}" target="_blank">${hike.trailheadName}</a>)</h3>
                                    <p>${formatHikeStartTime(hike.startTime)}</p>
                                    ${leaderLineRsvp}
                                    ${buttonHtml}
                                `;
                                rsvpList.appendChild(li);
                                foundRsvp = true;
                            } else if (hike.sourceType === 'led_by_user') {
                                buttonHtml = `<button onclick="goToLeaderConsole('${hike.joinCode}', '${hike.leaderCode}')">Open Coordinator Console</button>`;
                                li.innerHTML = `
                                    <h3>${hike.name} (TH: <a href="${makeTrailheadURL(hike)}" target="_blank">${hike.trailheadName}</a>)</h3>
                                    <p>${formatHikeStartTime(hike.startTime)}</p>
                                    <p>${currentUser.name} ${hike.organization ? '(' + hike.organization + ')' : ''}</p>
                                    ${buttonHtml}
                                `;
                                leadingList.appendChild(li);
                                foundLeading = true;
                            }
                        });
                    }

                    if (!foundNearby) {
                        nearbyList.innerHTML = '<li class="hike-item">No nearby hikes currently. Enable location or refresh.</li>';
                    }
                    if (!foundRsvp) {
                        rsvpList.innerHTML = '<li class="hike-item">You have not RSVPed to any hikes yet.</li>';
                    }
                    if (!foundLeading) {
                        leadingList.innerHTML = '<li class="hike-item">You are not currently leading any hikes.</li>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching all welcome page hikes:', error);
                    nearbyList.innerHTML = '<li>Error loading nearby hikes.</li>';
                    rsvpList.innerHTML = '<li>Error loading your RSVPed hikes.</li>';
                    leadingList.innerHTML = '<li>Error loading hikes you lead.</li>';
                });
        }


        function goToLeaderConsole(joinCode, leaderCode) {
            if (!joinCode || !leaderCode) {
                // This case might happen if leaderCode was not included in the hike object from the API
                // For 'led_by_user' source. We might need to fetch it separately or ensure backend provides it.
                // For now, try to fetch the hike details to get the leader code if it's missing.
                // This is a fallback, ideally leaderCode is directly available.
                fetch(`/api/hike/${joinCode}?leaderCode=temp`) // A bit of a hack to try and get leader details
                    .then(response => {
                        if (!response.ok) throw new Error('Hike not found or access denied.');
                        return response.json();
                    })
                    .then(hikeWithLeaderCode => {
                        if (hikeWithLeaderCode.leaderCode) {
                             // TODO: This logic is problematic. The getHikeHandler for leaderCode requires the leaderCode.
                             // The API needs to provide the leaderCode for hikes queried by userUUID where source is 'led_by_user'.
                             // For now, this button will likely fail if leaderCode isn't in the initial payload.
                             // A proper fix involves backend sending leaderCode for led_by_user hikes.
                             // As a temporary measure, this will likely not work as intended without backend change.
                            alert("Could not retrieve leader code for this hike. Navigating with join code only.");
                            window.location.href = `${window.location.origin}?code=${joinCode}`; // Fallback
                        } else {
                             // This will effectively try to load the hike as a participant if leaderCode is missing/wrong
                            window.location.href = `${window.location.origin}?code=${joinCode}`;
                        }
                    })
                    .catch(err => {
                        console.error("Error trying to navigate to leader console:", err);
                        alert("Could not navigate to coordinator console. The hike details might be incomplete or the hike has ended.");
                        // Fallback to just using joinCode if leaderCode is problematic
                         window.location.href = `${window.location.origin}?code=${joinCode}`;
                    });
                return;
            }
            // If leaderCode is present, directly navigate.
            window.location.href = `${window.location.origin}?code=${joinCode}&leaderCode=${leaderCode}`;
        }

        // getNearbyHikes, getRSVPedHikes, and getLeadingHikes are now consolidated into fetchAllWelcomePageHikes

        function showJoinHikePage(joinCode) {
            // Load currentUser into the form
            document.getElementById('participant-name').value = currentUser.name;
            document.getElementById('participant-phone').value = formatPhoneNumber(currentUser.phone);
            document.getElementById('participant-licensePlate').value = currentUser.licensePlate;
            document.getElementById('participant-emergencyContact').value = formatPhoneNumber(currentUser.emergencyContact);
            fetch(`/api/hike/${joinCode}`)
                .then(response => response.json())
                .then(hike => {
                    currentHike = hike;
                    localStorage.setItem('currentHike', JSON.stringify(currentHike));
                    document.getElementById('join-hike-name').textContent = currentHike.name;
                    document.getElementById('join-hike-organization').textContent = currentHike.organization;
                    document.getElementById('join-trailhead-name').textContent = currentHike.trailheadName;
                    document.getElementById('join-hike-start-time').textContent = formatHikeStartTime(currentHike.startTime);
                    document.getElementById('join-hike-description').textContent = currentHike.description || 'No description provided.';
                    showPage('join-hike-page');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to join hike. The hike may not exist or has already ended.');
                    clearCurrentHike();
                    showWelcomePage();
                });
        }

        function showCreateHikePage() {
            // Load currentUser into the form
            document.getElementById('leader-name').value = currentUser.name;
            document.getElementById('leader-phone').value = formatPhoneNumber(currentUser.phone);

            // Clear form fields for new hike
            document.getElementById('hike-name').value = '';
            document.getElementById('hike-organization').value = '';
            document.getElementById('hike-trailheadName').value = '';
            document.getElementById('hike-photo-release').checked = false; // Reset checkbox
            currentHike.name = ''; // Clear hike name in state
            currentHike.trailheadName = ''; // Clear trailhead name in state
            currentHike.latitude = 0;
            currentHike.longitude = 0;
            currentHike.photoRelease = false; // Reset in currentHike object
            currentHike.description = ''; // Reset description
            localStorage.setItem('currentHike', JSON.stringify(currentHike)); // Save cleared state

            document.getElementById('hike-description').value = ''; // Clear textarea
            document.getElementById('hike-name').focus(); // Focus on the custom hike name field first
            startTimeFlatpikr.setDate(formatDate(new Date()));
            showPage('create-hike-page');
        }

        // Function to format date for flatpickr
        function formatDate(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-based
            const dd = String(date.getDate()).padStart(2, '0');
            const hh = String(date.getHours()).padStart(2, '0');
            const m = String(date.getMinutes()).padStart(2, '0');

            return `${yyyy}-${mm}-${dd} ${hh}:${m}`;
        };

        // Save user data as it's entered into the join-hike-form
        // This assumes all user fields are prefixed with 'participant-' in the formS
        document.getElementById('join-hike-form').addEventListener('change', (e) => {
            const { id, value } = e.target;
            saveFieldChange(currentUser, 'currentUser', id, value, 'participant-');
        });

        // Save user and hike data as it's entered into the create-hike-form
        // This assumes all user fields are prefixed with 'leader-' and hike fields are prefixed with 'hike-' in the form
        document.getElementById('create-hike-form').addEventListener('change', (e) => {
            const { id, value } = e.target;
            saveFieldChange(currentUser, 'currentUser', id, value, 'leader-');
            saveFieldChange(currentHike, 'currentHike', id, value, 'hike-');
        });

        // Add blur event listener to hike-name for fetching last description
        document.getElementById('hike-name').addEventListener('blur', () => {
            const hikeName = document.getElementById('hike-name').value;
            const descriptionTextarea = document.getElementById('hike-description');
            // currentUser.uuid should be populated from localStorage or generated on load
            const leaderUUID = currentUser.uuid;

            if (hikeName && leaderUUID && descriptionTextarea.value.trim() === '') {
                fetch(`/api/hike/lastdescription?hikeName=${encodeURIComponent(hikeName)}&leaderUUID=${encodeURIComponent(leaderUUID)}`)
                    .then(response => {
                        if (!response.ok) {
                            // Don't alert errors here, just log, as it's a non-critical enhancement
                            console.error('Failed to fetch last description, status:', response.status);
                            return null;
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.description) {
                            descriptionTextarea.value = data.description;
                            // Also update currentHike in case the user doesn't change it further
                            currentHike.description = data.description;
                            localStorage.setItem('currentHike', JSON.stringify(currentHike));
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching or processing last description:', error);
                    });
            }
        });


        function saveFieldChange(store, storeName, fieldID, fieldValue, idPrefix) {
            const prop = fieldID.replace(idPrefix, '');
            if (store.hasOwnProperty(prop)) {
                store[prop] = fieldProcessors[prop]
                    ? fieldProcessors[prop](fieldValue)
                    : fieldValue;
                localStorage.setItem(storeName, JSON.stringify(store));
            }
        }

        // Functions to convert form values to correct format before saving
        const fieldProcessors = {
            phone: value => value.replace(/\D/g, ''), // Store only digits
            licensePlate: value => value.toUpperCase(),
            emergencyContact: value => value.replace(/\D/g, ''),
            startTime: value => new Date(value).toISOString(), // This is what SQLite expects
            description: value => value // No specific processing for description, just assign
        };

        function showHikeLeaderPage() {
            // Line 1: Hike Name (TH: linked trailheadname)
            const h1TitleSpan = document.getElementById('hike-name-title-display');
            const leaderHikeNameLink = document.getElementById('leader-hike-name-link');
            const trailheadLinkLeader = document.getElementById('trailhead-link-leader');
            const trailheadNameSpan = document.getElementById('trailhead-name-display');

            h1TitleSpan.textContent = currentHike.name;
            leaderHikeNameLink.setAttribute('data-description', currentHike.description || '');
            trailheadLinkLeader.href = makeTrailheadURL(currentHike);
            trailheadNameSpan.textContent = currentHike.trailheadName;
            // The H1 structure in HTML will be: <h1><a id="leader-hike-name-link"><span id="hike-name-title-display"></span></a> (TH: <a id="trailhead-link-leader"><span id="trailhead-name-display"></span></a>)</h1>

            // Line 2: Start Time
            document.getElementById('hike-start-time-leader-display').textContent = formatHikeStartTime(currentHike.startTime);

            // Line 3: Leader Name (Organization)
            // We need a new element for this or repurpose an existing one. Let's assume a new one: <p id="leader-org-display"></p>
            const leaderOrgDisplay = document.getElementById('leader-org-display'); // Assuming this element will be added to HTML
            leaderOrgDisplay.textContent = `${currentUser.name} ${currentHike.organization ? '(' + currentHike.organization + ')' : ''}`;

            // Hide old organization display if it's separate and no longer needed by new <p id="leader-org-display">
            const orgDisplayElement = document.getElementById('hike-organization-display');
            if (orgDisplayElement) orgDisplayElement.style.display = 'none';


            document.getElementById('participant-toggle').checked = showAllParticipants;
            document.getElementById('join-url').href = generateLink('code', currentHike.joinCode);
            document.getElementById('hike-leader-link').href = generateLink('leaderCode', currentHike.leaderCode);
            showPage('hike-leader-page');
            refreshParticipants();
        }

        function generateLink(codeType, code) {
            return `${window.location.origin}?${codeType}=${code}`;
        }

        function makeTrailheadURL(hike) {
            if (!hike || typeof hike.latitude === 'undefined' || typeof hike.longitude === 'undefined') {
                // console.error("Invalid hike object passed to makeTrailheadURL", hike);
                return "#"; // Return a safe default or handle error appropriately
            }
            // Use hike.trailheadName for the query_place_id if available, otherwise hike.name
            const placeIdQuery = hike.trailheadName || hike.name || '';
            return `https://www.google.com/maps/search/?api=1&query=${hike.latitude},${hike.longitude}&query_place_id=${encodeURIComponent(placeIdQuery)}`;
        }

        function showHikingPage() {
            // Line 1: Hike Name (TH: linked trailheadname)
            // Assuming h1 is: <h1><span id="current-hike-name"></span> (TH: <a id="current-trailhead-name" href="" target="_blank"></a>)</h1>
            document.getElementById('current-hike-name').textContent = currentHike.name;
            const trailheadLink = document.getElementById('current-trailhead-name');
            trailheadLink.textContent = currentHike.trailheadName;
            trailheadLink.href = makeTrailheadURL();

            // Line 2: Start Time
            document.getElementById('hike-start-time-display').textContent = formatHikeStartTime(currentHike.startTime);

            // Line 3: Leader Name (Organization)
            // Need a new element or repurpose. Let's assume <p id="hiking-leader-org"></p>
            const hikingLeaderOrgDisplay = document.getElementById('hiking-leader-org'); // Assuming this element will be added
            hikingLeaderOrgDisplay.textContent = `${currentHike.leader.name} ${currentHike.organization ? '(' + currentHike.organization + ')' : ''}`;

            // Line 4: Description
            document.getElementById('hiking-page-description').textContent = currentHike.description || 'No description available.';

            // Hide old individual displays if they are separate and no longer needed
            const orgDisplay = document.getElementById('current-hike-organization');
            if (orgDisplay) orgDisplay.style.display = 'none';
            const leaderNameDisplay = document.getElementById('leader-name-2');
            if (leaderNameDisplay) leaderNameDisplay.style.display = 'none';
            const leaderPhoneLinkContainer = document.getElementById('leader-phone-link-container'); // Assuming parent of phoneLink
            if (leaderPhoneLinkContainer) leaderPhoneLinkContainer.style.display = 'none';


            showPage('hiking-page');
        }

        function showWaiverPage() {
            // Ensure currentHike and currentHike.joinCode are available
            if (!currentHike || !currentHike.joinCode) {
                console.error('Cannot fetch waiver: currentHike or currentHike.joinCode is missing.');
                document.getElementById('waiver-content').innerText = 'Error: Hike details are missing. Cannot load waiver.';
                showPage('waiver-page');
                return;
            }

            fetch(`/api/hike/${currentHike.joinCode}/waiver`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch waiver: ${response.status} ${response.statusText}`);
                    }
                    return response.text();
                })
                .then(text => {
                    document.getElementById('waiver-content').innerText = text;
                })
                .catch(error => {
                    console.error('Error fetching waiver:', error);
                    document.getElementById('waiver-content').innerText = `Error loading waiver: ${error.message}. Please try again.`;
                });
            showPage('waiver-page');
        }

        function cancelWaiver() {
            clearCurrentHike();
            showWelcomePage();
        }

        function joinHike() {
            // The following two lines are because mobile browsers don't always trigger the change event
            currentUser.phone = document.getElementById('participant-phone').value.replace(/\D/g, '');
            currentUser.emergencyContact = document.getElementById('participant-emergencyContact').value.replace(/\D/g, '');
            const rsvpUrl = `/api/hike/${currentHike.joinCode}/participant`; // Changed endpoint
            if (!navigator.onLine) {
                addToRequestQueue(rsvpUrl, 'POST', rsvpBody);
                alert("You are offline. Your RSVP will be processed when you're back online.");
                // Consider also providing some UI feedback or redirecting.
                // For now, just returning to prevent fetch.
                return;
            }
            fetch(rsvpUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(currentUser)
            })
                .then(response => {
                    if (!response.ok) {
                        return response.text().then(text => { throw new Error(text || 'RSVP failed') });
                    }
                    return response.json();
                })
                .then(hike => { // hike object is returned on successful RSVP from backend
                    clearCurrentHike(); // Clear hike details as user is not actively hiking yet
                    showWelcomePage(); // Show welcome page which will refresh RSVP list
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert(`Failed to RSVP to hike: ${error.message}`);
                    // Do not clear currentHike here, user might want to retry
                    // showWelcomePage(); // Optionally, still go to welcome page or stay on waiver/join page
                });
        }

        function createHike() {
            if (!navigator.onLine) {
                addToRequestQueue('/api/hike', 'POST', JSON.stringify(currentHike));
                alert("You are offline. Your hike creation will be processed when you're back online.");
                // Similar to joinHike, consider UI feedback or state change.
                // For now, just returning.
                return;
            }

            currentHike.photoRelease = document.getElementById('hike-photo-release').checked;
            currentHike.description = document.getElementById('hike-description').value;

            // Get current location if not a predefined trail
            if (currentHike.latitude === 0 || currentHike.longitude === 0) {
                navigator.geolocation.getCurrentPosition(position => {
                    currentHike.latitude = position.coords.latitude;
                    currentHike.longitude = position.coords.longitude;
                }, error => {
                    console.error("Error getting location:", error);
                    alert("GPS location not found, participants will have to join via link code.");
                });
            }
            fetch('/api/hike', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(currentHike),
            })
                .then(response => response.json())
                .then(hike => {
                    currentHike = hike
                    currentHike.leader = currentUser;
                    localStorage.setItem('currentHike', JSON.stringify(currentHike));
                    showHikeLeaderPage();
                });
        }

        function endHike() {
            const endHikeUrl = `/api/hike/${currentHike.joinCode}?leaderCode=${currentHike.leaderCode}`;
            if (!navigator.onLine) {
                addToRequestQueue(endHikeUrl, 'PUT');
                alert("You are offline. Your request to end the hike will be processed when you're back online.");
                // Consider UI feedback here as well
                return;
            }
            fetch(endHikeUrl, { method: 'PUT' }) // Added { method: 'PUT' }
                .then(response => {
                    if (response.ok) {
                        clearCurrentHike();
                        showWelcomePage();
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert("An error occurred while trying to end the hike. Please try again.");
                });
        }

        function leaveHike() {
            // The offline check for toggleParticipantStatus will handle alerting the user
            // if they are offline. If that function adds to queue, then these next two lines
            // might run prematurely if offline. However, toggleParticipantStatus already calls
            // refreshParticipants on success, which is an online operation.
            // If offline, toggleParticipantStatus will return early.
            // The current logic is: if offline, user is alerted for the status update,
            // and they remain on the hiking page. If online, status is updated,
            // then they are taken to welcome page. This seems acceptable.
            toggleParticipantStatus(currentHike.participantId, 'finished');
            clearCurrentHike();
            showWelcomePage();
        }

        function showDescriptionPopup(event) {
            event.preventDefault();
            const description = event.target.getAttribute('data-description');
            alert(description || 'No description available.');
        }

        function goHomeFromLeaderConsole() {
            window.history.pushState({}, document.title, window.location.pathname); // Clear URL params
            clearCurrentHike(); // Clear any stored hike state
            showWelcomePage();  // Show the main welcome page
        }

        function cancelCreateHike() {
            showWelcomePage();
        }

        function cancelJoinHike() {
            clearCurrentHike();
            showWelcomePage();
        }

        // getLeadingHikes and getRSVPedHikes are removed and functionality merged into fetchAllWelcomePageHikes


        function startHiking(joinCode, participantId) {
            if (!currentUser || !currentUser.uuid) {
                alert("User information not found. Please reload the page.");
                return;
            }

            const startUrl = `/api/hike/${joinCode}/participant/${participantId}`;

            if (!navigator.onLine) {
                // It's tricky to handle this offline as "starting a hike" implies an immediate state change
                // and interaction. For now, we'll require online for this action.
                alert("You must be online to start hiking.");
                return;
            }

            fetch(startUrl, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json', // Though no body is sent, this is good practice
                },
                body: JSON.stringify({status: 'active'})
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        // Try to parse error if JSON, otherwise use text
                        try {
                            const errData = JSON.parse(text);
                            throw new Error(errData.error || text || 'Failed to start hike.');
                        } catch (e) {
                            throw new Error(text || 'Failed to start hike.');
                        }
                    });
                }
                // Backend should return the full hike object upon successful "start"
                // For now, we assume the backend returns *at least* the basic hike details needed
                // or we fetch them. The current backend returns 200 OK empty.
                // So, we need to fetch the hike details AFTER successfully starting.
                return fetch(`/api/hike/${joinCode}`); // Fetch full hike details
            })
            .then(response => { // This .then is for the fetch /api/hike/${joinCode}
                if (!response.ok) {
                    throw new Error('Failed to fetch hike details after starting.');
                }
                return response.json();
            })
            .then(hikeDetails => {
                currentHike = hikeDetails; // Populate currentHike with details
                 // If leader info is not in hikeDetails, we might need to supplement it
                if (!currentHike.leader || !currentHike.leader.uuid) {
                    // This is a fallback, ideally the /api/hike/{joinCode} includes full leader User object
                    console.warn("Leader details not fully provided by /api/hike endpoint, attempting to use currentUser if leader.");
                    // This assumption might be wrong if someone else is leader.
                    // The backend's GET /api/hike/{joinCode} should return leader User details.
                }
                currentHike.participantId = participantId
                localStorage.setItem('currentHike', JSON.stringify(currentHike));
                showHikingPage();
            })
            .catch(error => {
                console.error('Error starting hike:', error);
                alert(`Failed to start hike: ${error.message}`);
            });
        }

        function unRSVP(joinCode, participantId) {
            if (!participantId) {
                alert("Participant ID not found. Cannot unRSVP.");
                return;
            }

            const unRSVPUrl = `/api/hike/${joinCode}/participant/${participantId}`;

            if (!navigator.onLine) {
                // Similar to starting a hike, unRSVPing implies an immediate state change.
                // Requiring online for now. Could be queued, but adds complexity for UI feedback.
                alert("You must be online to unRSVP.");
                return;
            }

            fetch(unRSVPUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json', // Good practice
                }
            })
            .then(response => {
                if (!response.ok) {
                     return response.text().then(text => {
                        // Try to parse error if JSON, otherwise use text
                        try {
                            const errData = JSON.parse(text);
                            throw new Error(errData.error || text || 'Failed to unRSVP.');
                        } catch (e) {
                            throw new Error(text || 'Failed to unRSVP.');
                        }
                    });
                }
                // Expect HTTP 200 OK with no body, or could return a success message
                return response.text(); // Or response.json() if backend sends a json response
            })
            .then(responseText => { // If response.text() was used
                fetchAllWelcomePageHikes();
            })
            .catch(error => {
                console.error('Error unRSVPing:', error);
                alert(`Failed to unRSVP: ${error.message}`);
            });
        }

        function formatPhoneNumber(phoneNumberString) {
            const cleaned = ('' + phoneNumberString).replace(/\D/g, '');
            const match = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);
            if (match) {
                return match[1] + '-' + match[2] + '-' + match[3];
            }
            return null;
        }

        // Add event listeners to format phone numbers as they are typed
        document.querySelectorAll('input[type="tel"]').forEach(input => {
            input.addEventListener('input', function (e) {
                const cursorPosition = e.target.selectionStart;
                const value = e.target.value.replace(/\D/g, '');
                const formattedValue = formatPhoneNumber(value) || value;
                e.target.value = formattedValue;

                // Adjust cursor position
                const newCursorPosition = cursorPosition + (formattedValue.length - value.length);
                e.target.setSelectionRange(newCursorPosition, newCursorPosition);
            });
        });

        function copyToClipboard(event) {
            event.preventDefault(); // Prevent the link from navigating

            const link = event.target.href;
            navigator.clipboard.writeText(link)
                .then(() => alert("Link copied to clipboard!"))
                .catch(err => console.error("Failed to copy: ", err));
        }

        function toggleParticipants() {
            const toggleCheckbox = document.getElementById('participant-toggle');
            showAllParticipants = toggleCheckbox.checked;
            renderParticipants();
        }

        function refreshParticipants() {
            fetch(`/api/hike/${currentHike.joinCode}/participant?leaderCode=${currentHike.leaderCode}`)
                .then(response => response.json())
                .then(participants => {
                    allParticipants = participants || [];
                    renderParticipants();
                    document.getElementById('last-refresh').textContent = `Last refreshed: ${new Date().toLocaleTimeString()}`;
                });
        }

        function renderParticipants() {
            const participantList = document.getElementById('participant-list');
            participantList.innerHTML = '';

            const participantsToShow = allParticipants.filter(participant =>
                showAllParticipants || participant.status === 'active' || participant.status === 'rsvp'
            );

            let countMessage;
            const totalToShow = participantsToShow.length;
            if (showAllParticipants) {
                countMessage = `All: ${totalToShow}`;
            } else {
                const rsvpCount = participantsToShow.filter(p => p.status === 'rsvp').length;
                const activeCount = participantsToShow.filter(p => p.status === 'active').length;
                // Adjusted text: Removed "Showing" and "participants" after Hiking count
                countMessage = `RSVP: ${rsvpCount} & Hiking: ${activeCount} (Total: ${totalToShow})`;
            }
            document.getElementById('participant-count').textContent = countMessage;

            participantsToShow.forEach(participant => {
                const row = document.createElement('tr');

                // Name column
                const nameCell = document.createElement('td');
                nameCell.setAttribute('data-label', 'Name');
                const nameLink = document.createElement('a');
                nameLink.href = '#';
                nameLink.textContent = participant.user.name;
                nameLink.onclick = (e) => {
                    e.preventDefault();
                    showParticipantDetails(participant);
                };
                nameCell.appendChild(nameLink);
                row.appendChild(nameCell);

                // Phone column
                const phoneCell = document.createElement('td');
                phoneCell.setAttribute('data-label', 'Phone');
                const phoneLink = document.createElement('a');
                phoneLink.href = `tel:${participant.user.phone}`;
                phoneLink.textContent = formatPhoneNumber(participant.user.phone);
                phoneCell.appendChild(phoneLink);
                row.appendChild(phoneCell);

                // License Plate column (conditionally displayed via CSS)
                const licenseCell = document.createElement('td');
                licenseCell.setAttribute('data-label', 'License Plate');
                licenseCell.classList.add('col-wide-only');
                licenseCell.textContent = participant.user.licensePlate || 'N/A';
                row.appendChild(licenseCell);

                // Emergency Contact column (conditionally displayed via CSS)
                const emergencyCell = document.createElement('td');
                emergencyCell.setAttribute('data-label', 'Emergency Contact');
                emergencyCell.classList.add('col-wide-only');
                const emergencyContact = participant.user.emergencyContact;
                if (emergencyContact) {
                    const emergencyLink = document.createElement('a');
                    emergencyLink.href = `tel:${emergencyContact.replace(/\D/g, '')}`; // Use raw digits for tel:
                    emergencyLink.textContent = formatPhoneNumber(emergencyContact) || emergencyContact;
                    emergencyCell.appendChild(emergencyLink);
                } else {
                    emergencyCell.textContent = 'N/A';
                }
                row.appendChild(emergencyCell);

                // Status column
                const statusCell = document.createElement('td');
                statusCell.setAttribute('data-label', 'Status');
                const statusLink = document.createElement('a');
                statusLink.href = '#';
                // Display 'Hiking' for 'active' status, otherwise the status itself.
                let displayStatus = participant.status;
                if (participant.status === 'active') {
                    displayStatus = 'Hiking';
                }
                statusLink.textContent = displayStatus;

                // Only allow toggling for 'active' (Hiking) or 'finished' statuses by leader
                if (participant.status === 'active' || participant.status === 'finished') {
                    statusLink.onclick = (e) => {
                        e.preventDefault();
                        // Determine the new status: if active -> finished, if finished -> active
                        const targetStatus = participant.status === 'active' ? 'finished' : 'active';
                        toggleParticipantStatus(participant.id, targetStatus, participant.status);
                    };
                } else if (participant.status === 'rsvp') {
                    statusLink.style.cursor = 'default'; // Indicate non-interactive
                    statusLink.style.textDecoration = 'none'; // Remove underline
                    statusLink.onclick = (e) => e.preventDefault(); // Prevent any action
                }
                statusCell.appendChild(statusLink);
                row.appendChild(statusCell);

                participantList.appendChild(row);
            });
        }

        function showParticipantDetails(participant) {
            let displayStatus = participant.status;
            if (participant.status === 'active') {
                displayStatus = 'Hiking';
            }
            alert(`
                Name: ${participant.user.name}
                Phone: ${formatPhoneNumber(participant.user.phone)}
                License Plate: ${participant.user.licensePlate || 'N/A'}
                Emergency Contact: ${formatPhoneNumber(participant.user.emergencyContact) || 'N/A'}
                Status: ${displayStatus}
            `);
        }

        function toggleParticipantStatus(participantId, newStatus, currentStatus) { // Added currentStatus parameter
            // Leader can only toggle between 'active' (Hiking) and 'finished'.
            // RSVP status cannot be changed by the leader here.
            if (currentStatus !== undefined && currentStatus !== 'active' && currentStatus !== 'finished') {
                // alert("This participant's status cannot be changed by the leader from its current state (" + currentStatus + "). RSVP status is managed by the participant.");
                console.log("Leader attempted to toggle status for user " + userUUID + " with current status " + currentStatus + ". No action taken.");
                return;
            }

            const toggleUrl = `/api/hike/${currentHike.joinCode}/participant/${participantId}`;
            const toggleBody = JSON.stringify({ status: newStatus });
            if (!navigator.onLine) {
                addToRequestQueue(toggleUrl, 'PUT', toggleBody);
                alert("You are offline. The participant status update will be processed when you're back online.");
                // Consider UI feedback
                return;
            }
            fetch(toggleUrl, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: toggleBody,
            })
                .then(response => {
                    if (response.ok) {
                        refreshParticipants();
                    } else {
                        throw new Error('Failed to update participant status');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to update participant status. Please try again.');
                });
        }

        function generateParticipantCSV() {
            const headers = ['name', 'phone', 'licensePlate', 'emergencyContact', 'status', 'waiver'];
            const csvRows = [headers.join(',')];

            allParticipants.forEach(participant => {
                const row = [
                    participant.user.name,
                    participant.user.phone,
                    participant.user.licensePlate || '',
                    participant.user.emergencyContact || '',
                    participant.status || '',
                    participant.waiver || ''
                ];
                csvRows.push(row.join(','));
            });

            return csvRows.join('\n');
        }

        function downloadCSV(content, fileName) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function downloadParticipantList() {
            refreshParticipants();
            if (allParticipants.length === 0) {
                alert("No participants to download.");
                return;
            }
            const csvContent = generateParticipantCSV();
            downloadCSV(csvContent, `hike_participants_${currentHike.joinCode}.csv`);
        }


        // Autocomplete function for trailhead name input
        function autocomplete(inp) {
            var currentFocus;
            inp.addEventListener("input", function (e) {
                var a, b, i, val = this.value;
                closeAllLists();
                if (!val) { return false; }
                currentFocus = -1;
                a = document.createElement("DIV");
                a.setAttribute("id", this.id + "autocomplete-list");
                a.setAttribute("class", "autocomplete-items");
                this.parentNode.appendChild(a);

                fetch(`/api/trailhead?q=${val}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            for (i = 0; i < data.length; i++) {
                                b = document.createElement("DIV");
                                const matchIndex = data[i].name.toLowerCase().indexOf(val.toLowerCase());
                                if (matchIndex !== -1) {
                                    b.innerHTML = data[i].name.substr(0, matchIndex);
                                    b.innerHTML += "<strong>" + data[i].name.substr(matchIndex, val.length) + "</strong>";
                                    b.innerHTML += data[i].name.substr(matchIndex + val.length);
                                } else {
                                    b.innerHTML = data[i].name;
                                }
                                // Store trailhead info in hidden input attributes
                                b.innerHTML += '<input type="hidden" value="' + data[i].name + '" data-lat="' + data[i].latitude + '" data-lon="' + data[i].longitude + '">';
                                b.addEventListener("click", function (e) {
                                    const selectedInput = this.getElementsByTagName("input")[0];
                                    inp.value = selectedInput.value; // Set the input field value
                                    // Update currentHike with trailhead info
                                    currentHike.trailheadName = selectedInput.value;
                                    currentHike.latitude = parseFloat(selectedInput.getAttribute("data-lat"));
                                    currentHike.longitude = parseFloat(selectedInput.getAttribute("data-lon"));
                                    localStorage.setItem('currentHike', JSON.stringify(currentHike));
                                    closeAllLists();
                                });
                                a.appendChild(b);
                            }
                        }
                    });
            });
            inp.addEventListener("keydown", function (e) {
                var x = document.getElementById(this.id + "autocomplete-list");
                if (x) x = x.getElementsByTagName("div");
                if (e.keyCode == 40) { // Down
                    currentFocus++;
                    addActive(x);
                } else if (e.keyCode == 38) { // Up
                    currentFocus--;
                    addActive(x);
                } else if (e.keyCode == 13) {  // Enter
                    e.preventDefault();
                    if (currentFocus > -1) {
                        if (x) x[currentFocus].click();
                    }
                }
            });
            function addActive(x) {
                if (!x) return false;
                removeActive(x);
                if (currentFocus >= x.length) currentFocus = 0;
                if (currentFocus < 0) currentFocus = (x.length - 1);
                x[currentFocus].classList.add("autocomplete-active");
            }
            function removeActive(x) {
                for (const element of x) {
                    element.classList.remove("autocomplete-active");
                }
            }
            function closeAllLists(elmnt) {
                var x = document.getElementsByClassName("autocomplete-items");
                for (const element of x) {
                    if (elmnt !== element && elmnt !== inp) {
                        element.parentNode.removeChild(element);
                    }
                }
            }
            document.addEventListener("click", function (e) {
                closeAllLists(e.target);
            });
        }

        // Online status indicator logic
        const onlineStatusIndicator = document.getElementById('online-status-indicator');
        const syncStatusIndicator = document.getElementById('sync-status-indicator');

        function updateOnlineStatusIndicator() {
          if (navigator.onLine) {
            onlineStatusIndicator.style.display = 'none';
          } else {
            onlineStatusIndicator.textContent = 'Offline';
            onlineStatusIndicator.style.backgroundColor = 'lightcoral'; // Ensure this is applied
            onlineStatusIndicator.style.display = 'block';
          }
        }

        // Set initial status
        updateOnlineStatusIndicator();

        window.addEventListener('online', updateOnlineStatusIndicator);
        window.addEventListener('offline', updateOnlineStatusIndicator);

        function updateSyncStatusIndicator() {
          const queue = JSON.parse(localStorage.getItem('requestQueue')) || [];
          if (queue.length > 0) {
            syncStatusIndicator.textContent = `Pending sync: ${queue.length} item(s)`;
            syncStatusIndicator.style.display = 'block';
          } else {
            syncStatusIndicator.style.display = 'none';
          }
        }

        function addToRequestQueue(url, method, bodyString) { // bodyString is already JSON.stringified
          const request = { url, method, body: bodyString, timestamp: new Date().toISOString() };
          let queue = JSON.parse(localStorage.getItem('requestQueue')) || [];
          queue.push(request);
          localStorage.setItem('requestQueue', JSON.stringify(queue));
          updateSyncStatusIndicator();

          if ('serviceWorker' in navigator && 'SyncManager' in window) {
            navigator.serviceWorker.ready.then(registration => {
              registration.sync.register('hike-data-sync')
                .then(() => console.log('Background sync registered for hike-data-sync'))
                .catch(err => console.error('Background sync registration failed:', err));
            }).catch(err => console.error('Service worker not ready for sync registration:', err));
          } else {
            console.log('Background sync not supported by this browser.');
          }
        }
        // Call after definitions
        updateSyncStatusIndicator();
    </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js')
            .then(registration => {
              console.log('Service Worker registered successfully with scope:', registration.scope);
            })
            .catch(error => {
              console.log('Service Worker registration failed:', error);
            });
        });
      }
    </script>
</body>

</html>
